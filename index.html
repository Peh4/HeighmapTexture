<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Reporters sans frontières</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" href="knacss.css" media="all">
		<link rel="stylesheet" href="style.css" media="all">


		<!-- GOOGLE ANALYTICS -->
		<script type="text/javascript">

		  var _gaq = _gaq || [];
		  _gaq.push(['_setAccount', 'UA-2498778-1']);
		  _gaq.push(['_setDomainName', 'rsf.org']);
		  _gaq.push(['_trackPageview']);

		  (function() {
		    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		  })();

		</script>

	</head>

	<body>
		
		<div id="cp" class="line">
			<div class="txtcenter">
				<a href="http://rsf.org">
					<img class="w150p" src="http://fr.rsf.org/squelettes/img/fr/logo-fr.png" alt="logo RSF"/>
				</a>
				<br/>
				<br/>
				RSF rend public son rapport :
			</div>
			<h2>Classement de la liberté de la presse</h2>
			<p id="intro">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec ultrices nisl nunc, quis mattis quam iaculis quis. Cras a mollis metus. Aliquam nulla massa, hendrerit et facilisis eu, convallis non dui. Nulla orci tellus, auctor vel mauris et, iaculis lacinia tellus. Nunc felis sem, pellentesque vel risus ac, accumsan consequat dolor. Donec a orci a tortor ultrices pellentesque. Suspendisse dignissim nulla ultricies enim feugiat lacinia sit amet ut nulla. </p>
			<p id="more">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec ultrices nisl nunc, quis mattis quam iaculis quis. Cras a mollis metus. Aliquam nulla massa, hendrerit et facilisis eu, convallis non dui. Nulla orci tellus, auctor vel mauris et, iaculis lacinia tellus. Nunc felis sem, pellentesque vel risus ac, accumsan consequat dolor. Donec a orci a tortor ultrices pellentesque. Suspendisse dignissim nulla ultricies enim feugiat lacinia sit amet ut nulla. </p>
		</div>


		<div id="control_annees">
			
			<button id="btn_precedent" type="button">precedent</button>
			<span id="current_year">2013</span>
			<button id="btn_suivant" type="button">suivant</button>
			
		</div>

		
		<div id="control_mode">
			<button id="btn_2d" type="button">2d</button>
			<button id="btn_3d" type="button">3d</button>
		</div>


		<div id="carte">
			<div id="conteneurClassement">Classement
				<ul id="classement"></ul>
			</div>
		</div>



		<div id="sources" class="line">
			<h3>Sources</h3>
				Pew Research, Religion and Public Life Project, 21 novembre 2012 <a href="http://www.pewforum.org/2012/11/21/laws-penalizing-blasphemy-apostasy-and-defamation-of-religion-are-widespread/">source</a><br/>Zeev Maoz and Errol A. Henderson. “The World Religion Dataset, 1945-2010: Logic, Estimates, and trends.” International Interactions, 39(3) <a href="http://www.correlatesofwar.org/COW2%20Data/Religion/Religion.htm">source</a><br/>
			</p>
			<p>Data visualisation réalisée par Pierre-Alain Leboucher et Dorian Ratovo</br>
				à l'aide de <a href="http://d3js.org/">D3.js</a> de Mike Bostock</p>
			<h3>Changelog</h3>
			<ul>
				<li>18/12/2013 v.1.1 Amélioration des légendes et de la présentation de la répartition des croyants par pays.</li>
				<li>12/12/2013 v.1 </li>
			</ul>
		</div>





		<!--<script type="x-shader/x-vertex" id="vertexShader">

			attribute vec4 tangent;

			uniform vec2 uRepeatBase;

			uniform sampler2D tNormal;

			#ifdef VERTEX_TEXTURES

				uniform sampler2D tDisplacement;
				uniform float uDisplacementScale;
				uniform float uDisplacementBias;

			#endif

			varying vec3 vTangent;
			varying vec3 vBinormal;
			varying vec3 vNormal;
			varying vec2 vUv;

			varying vec3 vViewPosition;

			//THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			void main() {

				vNormal = normalize( normalMatrix * normal );

				// tangent and binormal vectors

				vTangent = normalize( normalMatrix * tangent.xyz );

				vBinormal = cross( vNormal, vTangent ) * tangent.w;
				vBinormal = normalize( vBinormal );

				// texture coordinates

				vUv = uv;

				vec2 uvBase = uv * uRepeatBase;

				// displacement mapping

				#ifdef VERTEX_TEXTURES

					vec3 dv = texture2D( tDisplacement, uvBase ).xyz;
					float df = uDisplacementScale * dv.x + uDisplacementBias;
					vec3 displacedPosition = normal * df + position;

					vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );
					vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );

				#else

					vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
					vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				#endif

				gl_Position = projectionMatrix * mvPosition;

				vViewPosition = -mvPosition.xyz;

				vec3 normalTex = texture2D( tNormal, uvBase ).xyz * 2.0 - 1.0;
				vNormal = normalMatrix * normalTex;

				// THREE.ShaderChunk[ "shadowmap_vertex" ],

			}

		</script>






		<script type="x-shader/x-fragment" id="fragmentShader">


			uniform vec3 uAmbientColor;
			uniform vec3 uDiffuseColor;
			uniform vec3 uSpecularColor;
			uniform float uShininess;
			uniform float uOpacity;

			uniform bool enableDiffuse1;
			uniform bool enableDiffuse2;
			uniform bool enableSpecular;

			uniform sampler2D tDiffuse1;
			uniform sampler2D tDiffuse2;
			uniform sampler2D tDetail;
			uniform sampler2D tNormal;
			uniform sampler2D tSpecular;
			uniform sampler2D tDisplacement;

			uniform float uNormalScale;

			uniform vec2 uRepeatOverlay;
			uniform vec2 uRepeatBase;

			uniform vec2 uOffset;

			varying vec3 vTangent;
			varying vec3 vBinormal;
			varying vec3 vNormal;
			varying vec2 vUv;

			uniform vec3 ambientLightColor;

			#if MAX_DIR_LIGHTS > 0

				uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];
				uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];

			#endif

			#if MAX_HEMI_LIGHTS > 0

				uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];
				uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];
				uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];

			#endif

			#if MAX_POINT_LIGHTS > 0

				uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];
				uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
				uniform float pointLightDistance[ MAX_POINT_LIGHTS ];

			#endif

			varying vec3 vViewPosition;

			// THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			// THREE.ShaderChunk[ "fog_pars_fragment" ],

			void main() {

				gl_FragColor = vec4( vec3( 1.0 ), uOpacity );

				vec3 specularTex = vec3( 1.0 );

				vec2 uvOverlay = uRepeatOverlay * vUv + uOffset;
				vec2 uvBase = uRepeatBase * vUv;

				vec3 normalTex = texture2D( tDetail, uvOverlay ).xyz * 2.0 - 1.0;
				normalTex.xy *= uNormalScale;
				normalTex = normalize( normalTex );

				if( enableDiffuse1 && enableDiffuse2 ) {

					vec4 colDiffuse1 = texture2D( tDiffuse1, uvOverlay );
					vec4 colDiffuse2 = texture2D( tDiffuse2, uvOverlay );

					#ifdef GAMMA_INPUT

						colDiffuse1.xyz *= colDiffuse1.xyz;
						colDiffuse2.xyz *= colDiffuse2.xyz;

					#endif

					gl_FragColor = gl_FragColor * mix ( colDiffuse1, colDiffuse2, 1.0 - texture2D( tDisplacement, uvBase ) );

				 } else if( enableDiffuse1 ) {

					gl_FragColor = gl_FragColor * texture2D( tDiffuse1, uvOverlay );

				} else if( enableDiffuse2 ) {

					gl_FragColor = gl_FragColor * texture2D( tDiffuse2, uvOverlay );

				}

				if( enableSpecular )
					specularTex = texture2D( tSpecular, uvOverlay ).xyz;

				mat3 tsb = mat3( vTangent, vBinormal, vNormal );
				vec3 finalNormal = tsb * normalTex;

				vec3 normal = normalize( finalNormal );
				vec3 viewPosition = normalize( vViewPosition );

				// point lights

				#if MAX_POINT_LIGHTS > 0

					vec3 pointDiffuse = vec3( 0.0 );
					vec3 pointSpecular = vec3( 0.0 );

					for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {

						vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );
						vec3 lVector = lPosition.xyz + vViewPosition.xyz;

						float lDistance = 1.0;
						if ( pointLightDistance[ i ] > 0.0 )
							lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );

						lVector = normalize( lVector );

						vec3 pointHalfVector = normalize( lVector + viewPosition );
						float pointDistance = lDistance;

						float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );
						float pointDiffuseWeight = max( dot( normal, lVector ), 0.0 );

						float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );

						pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;
						pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;

					}

				#endif

				// directional lights

				#if MAX_DIR_LIGHTS > 0

					vec3 dirDiffuse = vec3( 0.0 );
					vec3 dirSpecular = vec3( 0.0 );

					for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {

						vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );

						vec3 dirVector = normalize( lDirection.xyz );
						vec3 dirHalfVector = normalize( dirVector + viewPosition );

						float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );
						float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );

						float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );

						dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;
						dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;

					}

				#endif

				// hemisphere lights

				#if MAX_HEMI_LIGHTS > 0

					vec3 hemiDiffuse  = vec3( 0.0 );
					vec3 hemiSpecular = vec3( 0.0 );

					for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {

						vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );
						vec3 lVector = normalize( lDirection.xyz );

						// diffuse

						float dotProduct = dot( normal, lVector );
						float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;

						hemiDiffuse += uDiffuseColor * mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );

						// specular (sky light)

						float hemiSpecularWeight = 0.0;

						vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );
						float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;
						hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );

						// specular (ground light)

						vec3 lVectorGround = -lVector;

						vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );
						float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;
						hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );

						hemiSpecular += uSpecularColor * mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight ) * hemiSpecularWeight * hemiDiffuseWeight;

					}

				#endif

				// all lights contribution summation

				vec3 totalDiffuse = vec3( 0.0 );
				vec3 totalSpecular = vec3( 0.0 );

				#if MAX_DIR_LIGHTS > 0

					totalDiffuse += dirDiffuse;
					totalSpecular += dirSpecular;

				#endif

				#if MAX_HEMI_LIGHTS > 0

					totalDiffuse += hemiDiffuse;
					totalSpecular += hemiSpecular;

				#endif

				#if MAX_POINT_LIGHTS > 0

					totalDiffuse += pointDiffuse;
					totalSpecular += pointSpecular;

				#endif

				//gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor) + totalSpecular;
				gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );

				// THREE.ShaderChunk[ "shadowmap_fragment" ],
				// THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
				// THREE.ShaderChunk[ "fog_fragment" ]

			}


		</script>-->


		

		<script type="text/javascript" src="js/d3geo.js"></script>
		<script type="text/javascript" src="http://rsf.org/squelettes/lib/js/jquery-1.4.2.min.js"></script>
		<script type="text/javascript" src="js/d3.js"></script>
		<script type="text/javascript" src="js/three.js"></script>
		<script type="text/javascript" src="js/queue.js"></script>
		<script type="text/javascript" src="js/utils.js"></script>
		<script type="text/javascript" src="js/blur.js"></script>
		<script type="text/javascript" src="js/ShaderTerrain.js"></script>
		<script type="text/javascript" src="js/main.js"></script>

	</body>
</html>
